# OAUTH 2.0

#### **Terms**

* Client - The application which requests for authentication
* Resource Server - It's client's backend, Incase of confidential client, this keeps client\_secret safe from public. It exchanges code for access tokens with authorization server, verifies the access token & sends the access token to Client.
* Resource Owner - User requesting for a resource.
* Authorization Server - Server authorizing the user to access a resource - Google, Facebook, Okta etc

#### **OAUTH Parameters**

* client\_id - Used to identify client uniquely by authorization server
* client\_secret - client\_id & client\_secret together is used to authenticate client by authorization server.client\_secret needs to be kept secret for server side applications.
* redirect\_uri - client uri where user should be redirected after oauth grant is successful, this redirect url will receive authorization code & other important parameters such as state, which is sensitive.
* response\_type - response which client expects
  * token (Implicit Grant) - Directly client gets access & refresh token
  * code (Authorization Code Grant) - Client gets authorization code, code is exchanged for access & refresh token.&#x20;
* scope - permissions which user(access token) needs to be granted by authorization server like read, write, email
* state - state param is used like a csrf check, to verify it's the same person who started the authorization request only completes the callback.
* code - authorization code is sent in callback url for Authorization Code Grant flow which is later exchanged for access & refresh tokens.
* code\_challenge - Code challenge is used in PKCE grant type & is like a state param, but this is associated with particular authorization code, stored & validated by authorization server instead of client end.
* code\_verifier - code\_verifier is used in PKCE request during exchange of authorization code for access & refresh tokens, The code verifier should match code\_challenge sent during initial step.
* code\_challenge\_method - Code challenge can be either plain or S256 (SHA256 of code challenge & base64 encode the hash).
*   [grant\_type](https://oauth.net/2/grant-types/) -&#x20;

    1. authorization\_code - Authorization Code Grant Flow
    2. token -  Implicit Grant Flow
    3. PKCE - similar to authorization grant flow, but also include code\_challenge & code\_verifier which acts like state param, but code\_challenge is associated with particular authorization\_code, stored & validated at authorization server end, instead of client end incase of state param.
    4. password - username & password provided by client is sent to authorization server in exchange for access & refresh token.
    5. client\_credentials - client\_id & client\_secret is used to get access token, this is used to autheticate in client's auth context, not in user's context.





#### Implicit Grant Flow

1. User access Client which needs authentication.
2.  Client redirects user to OAUTH Authorization server's `/authorize` endpoint.



    ```
    https://authorization-server.com/authorize
     ?response_type=token
     &client_id=29352910282374239857
     &redirect_uri=https%3A%2F%2Fexample-app.com%2Fcallback
     &scope=create+delete
     &state=xcoiv98y3md22vwsuye3kch
    ```
3. User gives consent & authorizes Client in permission prompt.
4.  After authorization is successful, user is redirected to callback url mentioned in redirect\_uri parameter, with access\_token appended to url fragment of callback url.



    ```
    https://example-app.com/redirect
      #access_token=g0ZGZmNj4mOWIjNTk2Pw1Tk4ZTYyZGI3
      &token_type=Bearer
      &expires_in=600
      &state=xcoVv98y2kd44vuqwye3kcq
    ```

**Note**: This flow has become legacy, It's insecure as access\_token is passed in url, it will be present in browser history. This method also doesn't have client\_secret, Hence client authentication is also not done.





#### Authorization Code Grant Flow

1. User access Client which needs authentication.
2.  Client redirects user to OAUTH Authorization server's `/authorize` endpoint.



    ```
    https://authorization-server.com/auth
     ?response_type=code
     &client_id=29352915982374239857
     &redirect_uri=https%3A%2F%2Fexample-app.com%2Fcallback
     &scope=create+delete
     &state=xcoiv98y2kd22vusuye3kch
    ```
3. User gives consent & authorizes Client in permission prompt.
4.  After authorization is successful, user is redirected to callback url mentioned in redirect\_uri parameter, with access\_token appended to url fragment or as query parameter of callback url.



    ```
     https://example-app.com/callback?code=g0ZGZmNjVmOWIjNTk2NTk4ZTYyZGI3
     &state=xcoiv98y2kd22vusuye3kch
    ```
5.  Client sends authorization code to Resource Server(client's backend), mostly as a API request to backend.&#x20;

    ```
    https://example-app.com/api/sendCode?code=g0ZGZmNjVmOWIjNTk2NTk4ZTYyZGI3
     &client_id=29352915982374239857
     &state=xcoiv98y2kd22vusuye3kch
     &redirect_uri=https%3A%2F%2Fexample-app.com%2Fcallback
     &scope=create+delete
    ```
6.  Resource Server keeps client\_secret confidentially & uses authorization code, client\_id & client\_secret to obtain access token from authorization server by making a POST request to `/token` endpoint.



    ```
     https://authorization-server.com/oauth/token?grant_type=authorization_code
     &response_type=code
     &client_id=29352915982374239857
     &client_secret=xxxxxxxxxx
     &code=xxxxxxxxxxx
     &redirect_uri=https%3A%2F%2Fexample-app.com%2Fcallback
     &scope=create+delete
     &state=xcoiv98y2kd22vusuye3kch
    ```
7. Resource server obtains access & refresh token in response to `/token` request & sends that to Client as response to API request made in step 5.

**Note**: Here, as Resource Server(Client's backend) keeps client\_secret confidentially, this is known as **confidential client**.&#x20;

In some cases, native/mobile apps may need simple login feature without separate resource server, in that case client\_secret is present in native application/mobile app itself. Native/Mobile app itself makes `/token` request & obtains access token & refresh directly. This scenario is called as **public client**.

It's suggested to use confidential client wherever possible, as this ensures that anyone having authorization code cannot directly exchange code for access token without client\_secret.

**This doesn't fully prevent authorization code injection attack - Attacker with code can send API request to resource server(client's backend) as in step 5 with authorization code & can still obtain access & refresh tokens.**

#### Proof Key of Code Exchange (PKCE) Grant Flow

1. User access Client which needs authentication.
2. Client generates code\_verifier & transforms to code\_challenge(plain text or base64 encoding of SHA256 hash of code verifier)
3.  Client redirects user to OAUTH Authorization server's `/authorize` endpoint with code\_challenge added to it's query params.

    ```
    https://authorization-server.com/authorize
     ?response_type=token
     &client_id=29352910282374239857
     &redirect_uri=https%3A%2F%2Fexample-app.com%2Fcallback
     &scope=create+delete
     &state=xcoiv98y3md22vwsuye3kch
     &code_challenge_method={S256 or plain}
     &code_challenge=XXXXXXXXX
    ```
4. User gives consent & authorizes Client in permission prompt.
5. Authorization server associates code\_challenge & code\_challenge\_method with authorization code for this particular OAUTH consent request.
6.  After authorization is successful, user is redirected to callback url mentioned in redirect\_uri parameter, with access\_token appended to url fragment or as query parameter of callback url.



    ```
     https://example-app.com/callback?code=g0ZGZmNjVmOWIjNTk2NTk4ZTYyZGI3
     &state=xcoiv98y2kd22vusuye3kch
    ```
7.  Client uses code to exchange for access token by making `/token` POST request to authorization server(incase of public client)with code\_verifier added as query param .



    ```
     https://authorization-server.com/oauth/token?grant_type=authorization_code
     &response_type=code
     &client_id=29352915982374239857
     &client_secret=xxxxxxxxxx
     &code=xxxxxxxxxxx
     &redirect_uri=https%3A%2F%2Fexample-app.com%2Fcallback
     &scope=create+delete
     &state=xcoiv98y2kd22vusuye3kch
     &code_verifier=xxxxxxxxxxx
    ```
8. Authorization server uses associated code\_challenge\_method for the given authorization code to generate code\_challenge & verifies if it matches with code\_challenge initially associated as in step 5.
9. Client obtains access & refresh token as response to `/token` POST made in step 7 if PKCE auth is successful.

**Note**: Although this is mostly used in public clients, this is strongly suggested in confidential clients also, as this method prevents Authorization Code Injection vulnerability.

Attacker with only code cannot obtain access token without proper code\_verifier, as each code is uniquely associated with a code\_challenge, which is validated by authorization server.





#### Client Credentials Grant Flow

Client makes request `/token` POST request with it's client\_id & client\_secret to obtain access & refresh tokens in context of client's authentication(not user's session).

```
https://authorization-server.com/oauth/token?grant_type=client_credentials
 &client_id=29352915982374239857
 &client_secret=xxxxxxxxxx
```



#### Password Grant Flow

Client sends user's credentials in `/token` POST request along with client\_id & client\_secret to obtain access & refresh tokens of user.

```
https://authorization-server.com/oauth/token?grant_type=client_credentials
 &client_id=29352915982374239857
 &client_secret=xxxxxxxxxx
 &username=user@example.com
 &password=1234luggage
```

**Note**: Password Grant Flow is highly not recommended as in this case, client also gets user credentials, which is the main reason OAUTH is invented(prevent exposure of user credentials to Clients).



#### Understanding CSRF attack in OAUTH

1. Assume that Client supports 2 login functionalities - normal username/password & OAUTH login with social media account associated with the user.
2. User needs to first normally login & then only integrate his social media account.
3.  Assume Client uses below request to integrate social media account of user.

    ```
    https://example-app.com/api/OAUTHLinking?code=g0ZGZmNjVmOWIjNTk2NTk4ZTYyZGI3
     &client_id=29352915982374239857
     &redirect_uri=https%3A%2F%2Fexample-app.com%2FAssociateToken
     &scope=create+delete
    ```
4. `/OAUTHLinking` API in backend makes `/token` request to authorization server & exchanges code for access & refresh token & redirects Client to callback url mentioned. (Confidential client)
5.  `/AssociateToken` API associates the access & refresh token obtained from query params with the currently active user's session.

    ```
    https://example-app.com/api/AssociateToken?access_token=xxxxxxxxxx
     &refresh_token=xxxxxxxxxx
    ```
6. Given this scenario, attacker only needs to capture his own `/OAUTHLinking` request & send that to any user who is already logged in to client.This will automatically associate attacker's social media account with victim's session.

Note: This PortSwigger [lab](https://portswigger.net/web-security/oauth/lab-oauth-forced-oauth-profile-linking) explains this scenario in a very detailed manner.

Flow without CSRF Protection:

1. Client sends User to Authorization server
2. Authorization Server after authorizing redirects user to client call back url along with authorization code in url fragment.
3. Client uses code to exchange code for access\_token.

Flow with CSRF Protection using state param:

1. Client generates state param which is long & unique id & stores this locally.
2. Client sends User to Authorization server with state param.
3. Authorization Server after authorizing redirects user to client call back url along with authorization code & state param in url fragment.
4. Client ensures that state param received from Authorization Server is same as one that's locally stored.
5. Client uses code to exchange code for access\_token.

In scenario with CSRF protection with state param, client ensures that it's the same person who has initiated the OAUTH request & also arrived at the callback url by validating the state param at client end.

